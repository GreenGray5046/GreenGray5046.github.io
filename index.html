<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Aristocrat Cipher Game</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Times New Roman', Times, serif; }
body { background: #ffffff; color: #000000; min-height: 100vh; padding: 20px; display: flex; justify-content: center; }
.container { max-width: 1000px; width: 100%; background: #ffffff; padding: 25px; border: 2px solid #000; }
h1 { text-align: center; margin-bottom: 20px; font-size: 2rem; text-decoration: underline; }
.game-info { display:flex; justify-content:space-between; margin-bottom:16px; gap:8px; flex-wrap:wrap; }
.score, .timer { background:#f0f0f0; padding:10px 14px; font-weight:bold; border:1px solid #000; }
.cipher-container { background:#f8f8f8; padding:18px; border:1px solid #000; }
.cipher-row { display:flex; flex-wrap:wrap; justify-content:center; margin-bottom:8px; }
.cipher-char-container { display:flex; flex-direction:column; align-items:center; margin:0 3px; }
.cipher-char { width:36px; text-align:center; font-size:1.6rem; letter-spacing:2px; }
.cipher-input { width:36px; text-align:center; border:1px solid #000; font-size:1.2rem; height:32px; text-transform:uppercase; }
.cipher-input.active { border-color: #ff0000; background-color: #fff8f8; }
.space-block { width:20px; margin:0 3px; }
.controls { display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin:12px 0 14px 0; }
button { background:#f0f0f0; border:1px solid #000; padding:10px 16px; cursor:pointer; font-weight:bold; }
.frequency-chart-container { background:#f8f8f8; padding:12px; margin-top:16px; height:260px; border:1px solid #000; }
.solution-container { background:#f8f8f8; padding:12px; margin-top:16px; display:none; border:1px solid #000; }
.solution-text { font-size:1.2rem; text-align:center; }
.author { text-align:right; font-style:italic; margin-top:8px; font-size:1rem; }
.instructions { margin-top: 16px; padding: 12px; background: #f8f8f8; border: 1px solid #000; font-size: 0.9rem; }
</style>
</head>
<body>
<div class="container">

    <h1>Aristocrat Cipher Game</h1>

    <div class="game-info">
        <div class="score">Score: <span id="score-value">0</span></div>
        <div class="timer">Time: <span id="timer-value">00:00</span></div>
    </div>

    <div class="cipher-container">
        <div class="cipher-row" id="cipher-letters"></div>
        <div class="controls">
            <button id="new-quote-btn">New Quote</button>
            <button id="clear-btn">Clear All</button>
        </div>
    </div>

    <div class="instructions">
        <p><strong>Navigation:</strong> Use Arrow Keys to move between inputs. Auto-advance after entering a letter, auto-return after deleting.</p>
    </div>

    <div class="frequency-chart-container">
        <canvas id="frequency-chart"></canvas>
    </div>

    <div class="solution-container" id="solution-container">
        <div class="solution-text" id="solution-text"></div>
        <div class="author" id="author"></div>
    </div>

</div>

<script>
// ===== Wikiquote API helper =====
var WikiquoteApi = (function() {
    var wqa = {};
    var API_URL = "https://en.wikiquote.org/w/api.php";

    wqa.queryTitles = function(titles, success, error) {
        $.ajax({
            url: API_URL,
            dataType: "jsonp",
            data: { format:"json", action:"query", redirects:"", titles:titles },
            success: function(result) {
                var pages = result.query.pages;
                for(var p in pages) {
                    if(!("missing" in pages[p])) { success(pages[p].pageid); return; }
                }
                error("No results");
            },
            error: function() { error("Error processing your query"); }
        });
    };

    wqa.getSectionsForPage = function(pageId, success, error) {
        $.ajax({
            url: API_URL,
            dataType:"jsonp",
            data:{format:"json", action:"parse", prop:"sections", pageid:pageId},
            success:function(result){
                var secArr = [];
                var sections = result.parse.sections;
                for(var s in sections) {
                    var splitNum = sections[s].number.split('.');
                    if(splitNum.length>1 && splitNum[0]==="1") secArr.push(sections[s].index);
                }
                if(secArr.length===0) secArr.push("1");
                success({titles:result.parse.title, sections:secArr});
            },
            error:function(){ error("Error getting sections"); }
        });
    };

    wqa.getQuotesForSection = function(pageId, sectionIndex, success, error) {
        $.ajax({
            url:API_URL, dataType:"jsonp",
            data:{format:"json", action:"parse", noimages:"", pageid:pageId, section:sectionIndex},
            success:function(result){
                var quotes = result.parse.text["*"];
                var arr=[];
                var $lis=$(quotes).find('li:not(li li)');
                $lis.each(function(){
                    $(this).children().remove(':not(b)');
                    var $bolds=$(this).find('b');
                    arr.push($bolds.length>0?$bolds.html():$(this).html());
                });
                success({titles:result.parse.title, quotes:arr});
            },
            error:function(){ error("Error getting quotes"); }
        });
    };

    wqa.getRandomQuote=function(title, success, error){
        wqa.queryTitles(title, function(pageId){
            wqa.getSectionsForPage(pageId, function(sections){
                var sec = sections.sections[Math.floor(Math.random()*sections.sections.length)];
                wqa.getQuotesForSection(pageId, sec, function(res){
                    // Filter quotes by length (max 200 characters)
                    var validQuotes = res.quotes.filter(q => {
                        var clean = q.toUpperCase().replace(/[^A-Z ]/g,'');
                        return clean.length <= 200 && clean.length > 20;
                    });
                    
                    if (validQuotes.length === 0) {
                        error("No suitable quotes found");
                        return;
                    }
                    
                    var q = validQuotes[Math.floor(Math.random()*validQuotes.length)];
                    success({titles:res.titles, quote:q});
                }, error);
            }, error);
        }, error);
    };

    return wqa;
}());
</script>

<script>
// ===== Game state =====
const game = { 
    score:0, 
    time:0, 
    timer:null, 
    solution:"", 
    author:"", 
    cipherText:"", 
    cipherAlphabet:"", 
    mapping:{}, 
    chart:null,
    currentInputIndex: 0,
    inputs: []
};

const lettersDiv=document.getElementById("cipher-letters");
const scoreValue=document.getElementById("score-value");
const timerValue=document.getElementById("timer-value");
const solutionContainer=document.getElementById("solution-container");
const solutionText=document.getElementById("solution-text");
const authorText=document.getElementById("author");

// ===== Chart =====
function initChart(){
    game.chart=new Chart(document.getElementById("frequency-chart"), {
        type:"bar", 
        data:{
            labels:[], 
            datasets:[{
                data:[], 
                backgroundColor: '#4a4a4a',
                borderColor: '#000000',
                borderWidth: 1
            }]
        }, 
        options:{
            responsive:true, 
            maintainAspectRatio:false,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        stepSize: 1
                    }
                }
            },
            plugins: {
                legend: {
                    display: false
                }
            }
        }
    });
}
function updateChart(){
    const freq={};
    for(const ch of game.cipherText) if(ch!==" ") freq[ch]=(freq[ch]||0)+1;
    const arr=Object.entries(freq).sort((a,b)=>b[1]-a[1]);
    game.chart.data.labels=arr.map(e=>e[0]);
    game.chart.data.datasets[0].data=arr.map(e=>e[1]);
    game.chart.update();
}

// ===== Cipher =====
function generateCipher(){
    game.solution=game.solution.toUpperCase().replace(/[^A-Z ]/g,'');
    const alph="ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
    const shuffled=[...alph].sort(()=>Math.random()-0.5);
    game.cipherAlphabet=shuffled.join("");
    const map={}; for(let i=0;i<alph.length;i++) map[alph[i]]=shuffled[i];
    game.cipherText=[...game.solution].map(ch=>ch===" "? " ": map[ch]).join("");
    game.mapping={}; for(const c of shuffled) game.mapping[c]="";
}

function renderCipher(){
    lettersDiv.innerHTML="";
    game.inputs = [];
    
    [...game.cipherText].forEach((ch,i)=>{
        if(ch===" "){ 
            lettersDiv.innerHTML+="<div class='space-block'></div>"; 
            return; 
        }
        
        const container=document.createElement("div");
        container.className="cipher-char-container";
        
        const letterDiv=document.createElement("div");
        letterDiv.className="cipher-char"; 
        letterDiv.textContent=ch;
        
        const input=document.createElement("input");
        input.className="cipher-input"; 
        input.maxLength=1; 
        input.dataset.i=i;
        input.dataset.cipherChar=ch;
        
        input.addEventListener("input", handleInput);
        input.addEventListener("focus", handleFocus);
        input.addEventListener("keydown", handleKeydown);
        
        container.appendChild(letterDiv); 
        container.appendChild(input);
        lettersDiv.appendChild(container);
        
        game.inputs.push(input);
    });
    
    // Set focus to first input
    if (game.inputs.length > 0) {
        game.currentInputIndex = 0;
        game.inputs[0].focus();
    }
    
    updateChart();
}

function handleFocus(e) {
    // Update current input index
    const index = game.inputs.indexOf(e.target);
    if (index !== -1) {
        game.currentInputIndex = index;
    }
    
    // Update active state for all inputs
    game.inputs.forEach(input => input.classList.remove('active'));
    e.target.classList.add('active');
}

function handleKeydown(e) {
    const key = e.key;
    const input = e.target;
    
    // Handle arrow key navigation
    if (key === 'ArrowRight' || key === 'ArrowDown') {
        e.preventDefault();
        moveToNextInput();
    } else if (key === 'ArrowLeft' || key === 'ArrowUp') {
        e.preventDefault();
        moveToPrevInput();
    } else if (key === 'Backspace' && input.value === '') {
        e.preventDefault();
        // Auto-return after deleting
        moveToPrevInput();
        // Clear the previous input
        if (game.currentInputIndex >= 0) {
            const prevInput = game.inputs[game.currentInputIndex];
            const cipherLetter = prevInput.dataset.cipherChar;
            game.mapping[cipherLetter] = "";
            prevInput.value = "";
            
            // Update all inputs for this cipher letter
            document.querySelectorAll(".cipher-input").forEach(b=>{
                if(game.cipherText[b.dataset.i]==cipherLetter) b.value="";
            });
        }
    }
}

function moveToNextInput() {
    if (game.currentInputIndex < game.inputs.length - 1) {
        game.currentInputIndex++;
        game.inputs[game.currentInputIndex].focus();
    }
}

function moveToPrevInput() {
    if (game.currentInputIndex > 0) {
        game.currentInputIndex--;
        game.inputs[game.currentInputIndex].focus();
    }
}

function handleInput(e){
    const box=e.target, i=parseInt(box.dataset.i), cipherLetter=game.cipherText[i];
    const val=box.value.toUpperCase().replace(/[^A-Z]/g,'');
    game.mapping[cipherLetter]=val;
    
    // Update all inputs for this cipher letter
    document.querySelectorAll(".cipher-input").forEach(b=>{
        if(game.cipherText[b.dataset.i]==cipherLetter) b.value=val;
    });
    
    // Auto-advance to next input after filling
    if (val !== '' && game.currentInputIndex < game.inputs.length - 1) {
        moveToNextInput();
    }
    
    checkSolved();
}

function checkSolved(){
    for(let i=0;i<game.solution.length;i++){
        const plain=game.solution[i];
        if(plain==="") continue;
        if(game.mapping[game.cipherText[i]]!==plain) return false;
    }
    clearInterval(game.timer);
    game.score+=50; scoreValue.textContent=game.score;
    solutionText.textContent=`"${game.solution}" – solved in ${formatTime(game.time)}`;
    authorText.textContent=`– ${game.author}`;
    solutionContainer.style.display="block";
}

function resetTimer(){
    clearInterval(game.timer); game.time=0; timerValue.textContent="00:00";
    game.timer=setInterval(()=>{game.time++; timerValue.textContent=formatTime(game.time);},1000);
}
function formatTime(t){return `${String(Math.floor(t/60)).padStart(2,"0")}:${String(t%60).padStart(2,"0")}`;}

function clearAllInputs() {
    game.inputs.forEach(input => {
        input.value = '';
    });
    game.mapping = {};
    game.currentInputIndex = 0;
    if (game.inputs.length > 0) {
        game.inputs[0].focus();
    }
}

// ===== Quote fetch =====
function loadNewQuote(){
    const authors=["Socrates","Mahatma Gandhi","Albert Einstein","Aristotle","Confucius"];
    const author=authors[Math.floor(Math.random()*authors.length)];
    WikiquoteApi.getRandomQuote(author, function(result){
        game.solution=result.quote.toUpperCase().replace(/[^A-Z ]/g,'');
        game.author=result.titles;
        generateCipher();
        renderCipher();
        resetTimer();
        solutionContainer.style.display="none";
    }, function(err){
        // fallback
        const fallbackQuotes=[
            "THE ONLY TRUE WISDOM IS IN KNOWING YOU KNOW NOTHING",
            "BE THE CHANGE THAT YOU WISH TO SEE IN THE WORLD",
            "LIFE IS WHAT HAPPENS WHEN YOU ARE BUSY MAKING OTHER PLANS",
            "THE WAY TO GET STARTED IS TO QUIT TALKING AND BEGIN DOING"
        ];
        const fallbackAuthors=["SOCRATES","MAHATMA GANDHI", "JOHN LENNON", "WALT DISNEY"];
        const i=Math.floor(Math.random()*fallbackQuotes.length);
        game.solution=fallbackQuotes[i]; game.author=fallbackAuthors[i];
        generateCipher(); renderCipher(); resetTimer(); solutionContainer.style.display="none";
    });
}

// ===== Init =====
window.onload=()=>{
    initChart();
    loadNewQuote();
};
document.getElementById("new-quote-btn").onclick=loadNewQuote;
document.getElementById("clear-btn").onclick=clearAllInputs;

// Disable Tab navigation
document.addEventListener('keydown', function(e) {
    if (e.key === 'Tab') {
        e.preventDefault();
    }
});
</script>
</body>
</html>
